# Global AI Configuration

<!-- This file is automatically generated from component files in ~/.config/ai/global/ -->
<!-- Do not edit directly - edit the component files instead -->

<!-- File: code-style.json -->
## Code Style

```json
{
	"code_style": {
		"rules": [
			"Always use TypeScript over JavaScript",
			"Prefer const/let over var",
			"Use async/await over .then() chains",
			"Keep functions under 20 lines when possible",
			"Use descriptive names: `getUserById()` not `getUser()`",
			"Keep components small and single-purpose",
			"Separate business logic from presentation components",
			"Follow separation of concerns patterns",
			"Use custom hooks for reusable logic",
			"Use JSDoc-style comments: /** ... */"
		]
	}
}
```

<!-- File: design-preferences.json -->
## Design Preferences

```json
{
	"design_preferences": {
		"icons": {
			"rules": ["Avoid creating your own SVGs. When possible, use icons from:"],
			"sources": [
				{
					"name": "Hero Icons",
					"url": "https://heroicons.com/"
				},
				{
					"name": "Tabler",
					"url": "tabler"
				},
				{
					"name": "Lucide",
					"url": "https://lucide.dev/icons/categories#brands"
				}
			]
		}
	}
}
```

<!-- File: emotional-neutrality.json -->
## Emotional Neutrality

```json
{
	"emotional_neutrality": {
		"rules": [
			"No comments on emotional states or empathy. Respond only to request.",
			"No praise or feedback on prompts."
		],
		"avoid_phrases": [
			"Great question!",
			"Perfect!",
			"Excellent point",
			"Any enthusiasm or praise language"
		],
		"avoid_unnecessary_emotional_words": [
			{
				"instead_of": "I completely agree",
				"say": "I agree"
			},
			{
				"instead_of": "you're absolutely right",
				"say": "you're right"
			}
		]
	}
}
```

<!-- File: factual-verification.json -->
## Factual Verification

```json
{
	"factual_verification": {
		"rules": [
			"Verify all claims with up-to-date sources before responding. Assume your information is out-of-date.",
			"Mark unverified claims as such.",
			"Presenting unverified info as fact is invalid."
		]
	},
	"no_speculative_inference": {
		"rules": [
			"No inference as fact unless marked as \"inferred, not verified.\"",
			"Inferences must be justified, with final judgment deferred to the user."
		]
	},
	"critical_analysis": {
		"rules": [
			"Challenge incorrect assumptions or approaches.",
			"Provide alternative solutions when the current approach has issues.",
			"Point out potential problems before implementation.",
			"Disagree when evidence supports a different conclusion."
		]
	},
	"instruction_compliance": {
		"rules": [
			"Violations require immediate stop, acknowledgment, and correction.",
			"Violations reset trust to zero."
		]
	},
	"zero_trust": {
		"rules": [
			"Start with zero trust. Violations reset trust to zero.",
			"No action on unverified or uncertain information."
		]
	},
	"verification_workflow": {
		"rules": [
			"Verify all information before presenting it as fact.",
			"Mark unverified information as \"confirmation required.\"",
			"Skipping verification is a violation."
		]
	},
	"no_continuation_after_error": {
		"rules": [
			"Violations require immediate stop and correction before proceeding."
		]
	}
}
```

<!-- File: mcp.json -->
## Mcp

```json
{
	"calls": [
		{
			"match": "when working on this project, always consult the memory graph first to understand architecture, widget relationships, and system depyndencies before making changes or providing guidance",
			"tool": "memory"
		},
		{
			"match": "when the user asks about Git, or when you need to run Git operations",
			"tool": "git"
		},
		{
			"match": "when the user requests code examples, setup or configuration steps, or library/API documentation",
			"tool": "context7"
		},
		{
			"match": "when the user asks about Shopify API, Liquid, theme development, app development, or anything on the Shopify platform",
			"tool": "shopify-dev-mcp"
		},
		{
			"match": "when the user requests file operations (reading, writing, navigating dotfiles or configs)",
			"tool": "filesystem"
		},
		{
			"match": "when the user asks about Prisma ORM, database schema design, migrations, or queries",
			"tool": "prisma-mcp-server"
		},
		{
			"match": "when the user inquires about shadcn/ui components, design system usage, or UI styling",
			"tool": "shadcn-ui-server"
		}
	]
}
```

<!-- File: astro-preferences.md -->
# Astro Patterns

## General

- Always use the latest version of Astro. If you're not sure, check.
- Use Astro components for static content
- React components only when interactivity needed
- Leverage Astro's partial hydration
- Use content collections for structured data
- Keep bundle size minimal with selective hydration

## Adapters

- Always use `@astrojs/vercel` and assume Vercel for hosting

## Database

- For a new project, always initially use Astro DB, Astro's included database

<!-- File: nextjs-preferences.md -->
# Next.js Patterns

- Always refer to the latest version of Next.js
- Always use Next.js app directory
- Always use Next.js serve - Dynamic imports for heavy components
- Use next/image for all images
- Keep API routes thin, business logic in separate filesr components, unless client-side reactivity is required

## Validation

- Prefer use `zod` for validation

## Forms

- Prefer Tanstack Form

## Authentication

- Prefer use `better-auth`

<!-- File: oop-patterns.md -->
# Object-Oriented Programming (OOP) Patterns

1. Favor Composition Over Inheritance

When to apply: Modeling behaviors that may vary independently over time.Patterns: Strategy, Bridge. Explanation: Strategy encapsulates interchangeable algorithms behind a common interface; Bridge decouples abstractions from implementations to allow independent variation.Do: Compose objects via constructor injection.

```ts
class Engine {}
class Car {
  constructor(private engine: Engine) {}
}
```

Don't: Extend classes for behavior reuse.

2. Dependency Injection (DI)

When to apply: Service layers, repositories, external integrations.Patterns: Service Locator (avoid), DI Container. Explanation: DI Container centralizes object creation and injection; Service Locator offers a registry for dependencies but leads to hidden coupling.Do: Inject typed interfaces rather than new.

```ts
class UserService {
  constructor(private repo: UserRepository) {}
}
```

Don't: Hardcode dependencies inside classes.

3. Tell, Donâ€™t Ask

When to apply: Encapsulated domain logic.Patterns: Command, Method Invocation. Explanation: Command encapsulates actions as objects enabling undo/redo; Method Invocation treats method calls as explicit instructions.Do: Call behavior methods.

```ts
order.complete();
```

Don't: Inspect internals then mutate externally.

4. Law of Demeter

When to apply: Any object collaboration.Patterns: N/A. Explanation: Law of Demeter is a design guideline advising minimal coupling by limiting method calls to immediate collaborators.Do: Use only immediate collaborators.

```ts
user.changeEmail(newEmail);
```

Don't: Chain deep property/method calls.

5. Make Impossible States Impossible

When to apply: State machines, config objects.Patterns: Discriminated Unions. Explanation: TypeScript feature modeling a set of exclusive states via tagged unions, ensuring compile-time validity.Do: Encode valid states in types.

```ts
type Loading = { status: "loading" };
type Loaded<T> = { status: "loaded"; data: T };
```

Don't: Validate core states only at runtime.

6. Combat Primitive Obsession

When to apply: Domain value objects.Patterns: Value Object. Explanation: Encapsulates simple domain concepts in immutable classes with built-in validation.Do: Wrap primitives in classes with validation.

```ts
class Email {
  constructor(public readonly value: string) {
    if (!value.includes("@")) throw new Error("Invalid email");
  }
}
```

Don't: Pass raw strings or numbers around.

7. Replace Conditionals with Polymorphism

When to apply: Varying algorithms/behaviors.Patterns: Strategy. Explanation: Defines a family of interchangeable algorithms, encapsulating each in its own class behind a common interface.Do: Define interfaces and inject implementations.

```ts
interface PaymentStrategy {
  pay(amount: number): void;
}
```

Don't: Use if/else chains or switch for behavior.

8. Liskov Substitution Principle (LSP)

When to apply: Subtype creation.Patterns: Inheritance. Explanation: Establishes is-a relationships, allowing subclasses to reuse and extend base class behavior.Do: Ensure derived classes honor base contracts.

Don't: Change postconditions or omit base behavior.

9. Interface Segregation Principle (ISP)

When to apply: Public API design.Patterns: Interface Abstraction. Explanation: Segregates broad interfaces into smaller, focused ones to reduce unnecessary dependencies.Do: Create small, focused interfaces.

Don't: Force extra methods on implementers.

10. Dependency Inversion Principle (DIP)

When to apply: Module boundary design.Patterns: Abstraction Layer. Explanation: Introduces interfaces or abstract classes between modules, inverting dependencies to decouple high- and low-level components.Do: Depend on interfaces, not implementations.

Don't: Import concrete classes in high-level modules.

11. Fail Fast & Guards

When to apply: Input validation and invariants.Patterns: Guard Clause. Explanation: Early-exit checks at the start of functions to validate inputs and enforce invariants promptly.Do: Use centralized guards for preconditions.

```ts
function assertEmail(email: string): asserts email is string {
  if (!email.includes("@")) throw new Error("Invalid email");
}
```

Don't: Let invalid data flow silently.

12. Observers & Events

When to apply: Cross-object notifications.Patterns: Observer, Event Emitter. Explanation: Observer defines a publisher-subscriber model for change notifications; Event Emitter provides a simple API to register and trigger event handlers.Do: Decouple publishers and subscribers.

```ts
class EventEmitter<T> { /_ subscribe/publish API _/ }
```

Don't: Directly call listener logic in source classes.

Global Heuristics & Edge Cases

Inheritance vs. Composition: Use inheritance only for true is-a relationships.

Controlled Querying: Permit minimal getters when necessary, but encapsulate decisions in methods.

Pragmatism: If strict adherence impairs clarity, annotate exceptions with comments explaining rationale.

<!-- File: react-preferences.md -->
# React Patterns

## General

- Always pass the arg `props` and then destructure it in the component body
- Always used named exports for React components
- Use functional components over class components
- Custom hooks for shared logic
- Prefer composition over inheritance
- Use React.memo for expensive renders
- Keep state as close to where it's used as possible

## UI

- Always use [shadcn](https://ui.shadcn.com/docs/installation) for UI components.

## Hooks

- Always use React hooks at the top level of your component

## State Management

- Use React Context and Zustand where appropriate
- Use Tanstack Query for data fetching when server state is required
- Use URL parameters for client-side state when appropriate

## Additional Libraries

- Use `ahooks` for
  - `useControlledValue`
  - `useResponsive`

<!-- File: typescript-preferences.md -->
# TypeScript Preferences

## Alphabetical Property Ordering

All added properties to any object shall be in alphabetical order. This includes:

- Object literals
- Interface definitions
- Type definitions
- Function parameters (when destructuring)
- Import/export statements
- Configuration objects

```ts
// GOOD - alphabetical order
const config = {
  apiKey: "key",
  baseUrl: "url",
  debug: true,
  timeout: 5000,
};

// BAD - random order
const config = {
  timeout: 5000,
  apiKey: "key",
  debug: true,
  baseUrl: "url",
};
```

## Any inside generic functions

When building generic functions, you may need to use any inside the function body.

This is because TypeScript often cannot match your runtime logic to the logic done inside your types.

One example:

```ts
const youSayGoodbyeISayHello = <TInput extends "hello" | "goodbye">(
  input: TInput,
): TInput extends "hello" ? "goodbye" : "hello" => {
  if (input === "goodbye") {
    return "hello"; // Error!
  } else {
    return "goodbye"; // Error!
  }
};
```

On the type level (and the runtime), this function returns `goodbye` when the input is `hello`.

There is no way to make this work concisely in TypeScript.

So using `any` is the most concise solution:

```ts
const youSayGoodbyeISayHello = <TInput extends "hello" | "goodbye">(
  input: TInput,
): TInput extends "hello" ? "goodbye" : "hello" => {
  if (input === "goodbye") {
    return "hello" as any;
  } else {
    return "goodbye" as any;
  }
};
```

Outside of generic functions, use `any` extremely sparingly.

## Throwing

Think carefully before implementing code that throws errors.

If a thrown error produces a desirable outcome in the system, go for it. For instance, throwing a custom error inside a backend framework's request handler.

However, for code that you would need a manual try catch for, consider using a result type instead:

```ts
type Result<T, E extends Error> =
  | { ok: true; value: T }
  | { ok: false; error: E };
```

For example, when parsing JSON:

```ts
const parseJson = (input: string): Result<unknown, Error> => {
  try {
    return { ok: true, value: JSON.parse(input) };
  } catch (error) {
    return { ok: false, error: error as Error };
  }
};
```

This way you can handle the error in the caller:

```ts
const result = parseJson('{"name": "John"}');

if (result.ok) {
  console.log(result.value);
} else {
  console.error(result.error);
}
```

## Return types

When declaring functions on the top-level of a module,
declare their return types. This will help future AI
assistants understand the function's purpose.

```ts
const myFunc = (): string => {
  return "hello";
};
```

One exception to this is components which return JSX.
No need to declare the return type of a component,
as it is always JSX.

```tsx
const MyComponent = () => {
  return <div>Hello</div>;
};
```

## Read-only properties

Use `readonly` properties for object types by default. This will prevent accidental mutation at runtime.

Omit `readonly` only when the property is genuinely mutable.

```ts
// BAD
type User = {
  id: string;
};

const user: User = {
  id: "1",
};

user.id = "2";
```

```ts
// GOOD
type User = {
  readonly id: string;
};

const user: User = {
  id: "1",
};

user.id = "2"; // Error
```

## Optional properties

Use optional properties extremely sparingly. Only use them when the property is truly optional, and consider whether bugs may be caused by a failure to pass the property.

In the example below we always want to pass user ID to `AuthOptions`. This is because if we forget to pass it somewhere in the code base, it will cause our function to be not authenticated.

```ts
// BAD
type AuthOptions = {
  userId?: string;
};

const func = (options: AuthOptions) => {
  const userId = options.userId;
};
```

```ts
// GOOD
type AuthOptions = {
  userId: string | undefined;
};

const func = (options: AuthOptions) => {
  const userId = options.userId;
};
```

## No unchecked indexed access

If the user has this rule enabled in their `tsconfig.json`, indexing into objects and arrays will behave differently from how you expect.

```ts
const obj: Record<string, string> = {};

// With noUncheckedIndexedAccess, value will
// be `string | undefined`
// Without it, value will be `string`
const value = obj.key;
```

```ts
const arr: string[] = [];

// With noUncheckedIndexedAccess, value will
// be `string | undefined`
// Without it, value will be `string`
const value = arr[0];
```

## Naming conventions

- Use kebab-case for file names (e.g., `my-component.ts`)
- Use camelCase for variables and function names (e.g., `myVariable`, `myFunction()`)
- Use UpperCamelCase (PascalCase) for classes, types, and interfaces (e.g., `MyClass`, `MyInterface`)
- Use ALL_CAPS for constants and enum values (e.g., `MAX_COUNT`, `Color.RED`)
- Inside generic types, functions or classes, prefix type parameters with `T` (e.g., `TKey`, `TValue`)

```ts
type RecordOfArrays<TItem> = Record<string, TItem[]>;
```

## JSDoc comments

Use JSDoc comments to annotate functions and types.

Be concise in JSDoc comments, and only provide JSDoc comments if the function's behaviour is not self-evident.

Use the JSDoc inline `@link` tag to link to other functions and types within the same file.

```ts
/**
 * Subtracts two numbers
 */
const subtract = (a: number, b: number) => a - b;

/**
 * Does the opposite to {@link subtract}
 */
const add = (a: number, b: number) => a + b;
```

## Interface extends

ALWAYS prefer interfaces when modeling inheritance.

The `&` operator has terrible performance in TypeScript. Only use it where `interface extends` is not possible.

```ts
// BAD

type A = {
  a: string;
};

type B = {
  b: string;
};

type C = A & B;
```

```ts
// GOOD

interface A {
  a: string;
}

interface B {
  b: string;
}

interface C extends A, B {
  // Additional properties can be added here
}
```

## Installing libraries

When installing libraries, do not rely on your own training data.

Your training data has a cut-off date. You're probably not aware of all of the latest developments in the JavaScript and TypeScript world.

This means that instead of picking a version manually (via updating the `package.json` file), you should use a script to install the latest version of a library.

```bash
## pnpm
pnpm add -D @typescript-eslint/eslint-plugin

## yarn
yarn add -D @typescript-eslint/eslint-plugin

## npm
npm install --save-dev @typescript-eslint/eslint-plugin
```

This will ensure you're always using the latest version.

## Import type

Use import type whenever you are importing a type.

Prefer top-level `import type` over inline `import { type ... }`.

```ts
// BAD
import { type User } from "./user";
```

```ts
// GOOD
import type { User } from "./user";
```

The reason for this is that in certain environments, the first version's import will not be erased. So you'll be left with:

```ts
// Before transpilation
import { type User } from "./user";

// After transpilation
import "./user";
```

## Enums

Do not introduce new enums into the codebase. Retain existing enums.

If you require enum-like behaviour, use an `as const` object:

```ts
const backendToFrontendEnum = {
  xs: "EXTRA_SMALL",
  sm: "SMALL",
  md: "MEDIUM",
} as const;

type LowerCaseEnum = keyof typeof backendToFrontendEnum; // "xs" | "sm" | "md"

type UpperCaseEnum = (typeof backendToFrontendEnum)[LowerCaseEnum]; // "EXTRA_SMALL" | "SMALL" | "MEDIUM"
```

Remember that numeric enums behave differently to string enums. Numeric enums produce a reverse mapping:

```ts
enum Direction {
  Up,
  Down,
  Left,
  Right,
}

const direction = Direction.Up; // 0
const directionName = Direction[0]; // "Up"
```

This means that the enum `Direction` above will have eight keys instead of four.

```ts
enum Direction {
  Up,
  Down,
  Left,
  Right,
}

Object.keys(Direction).length; // 8
```

## Discriminated unions

Proactively use discriminated unions to model data that can be in one of a few different shapes.

For example, when sending events between environments:

```ts
type UserCreatedEvent = {
  type: "user.created";
  data: { id: string; email: string };
};

type UserDeletedEvent = {
  type: "user.deleted";
  data: { id: string };
};

type Event = UserCreatedEvent | UserDeletedEvent;
```

Use switch statements to handle the results of discriminated unions:

```ts
const handleEvent = (event: Event) => {
  switch (event.type) {
    case "user.created":
      console.log(event.data.email);
      break;
    case "user.deleted":
      console.log(event.data.id);
      break;
  }
};
```

Use discriminated unions to prevent the 'bag of optionals' problem.

For example, when describing a fetching state:

```ts
// BAD - allows impossible states
type FetchingState<TData> = {
  status: "idle" | "loading" | "success" | "error";
  data?: TData;
  error?: Error;
};

// GOOD - prevents impossible states
type FetchingState<TData> =
  | { status: "idle" }
  | { status: "loading" }
  | { status: "success"; data: TData }
  | { status: "error"; error: Error };
```

## Default exports

Unless explicitly required by the framework, do not use default exports.

```ts
// BAD
export default function myFunction() {
  return <div>Hello</div>;
}
```

```ts
// GOOD
export function myFunction() {
  return <div>Hello</div>;
}
```

Default exports create confusion from the importing file.

```ts
// BAD
import myFunction from "./myFunction";
```

```ts
// GOOD
import { myFunction } from "./myFunction";
```

There are certain situations where a framework may require a default export. For instance, Next.js requires a default export for pages.

```tsx
// This is fine, if required by the framework
export default function MyPage() {
  return <div>Hello</div>;
}
```
