import * as fs from 'fs-extra';
import * as path from 'path';
import { execSync } from 'child_process';
import type { FileOperationResult } from '../types/sync';
import { FILE_TYPES, ProcessedFile, DEFAULT_GLOBAL_CONFIG_PATH } from '../types/config';
import { getGlobalConfigPaths } from '../config/paths';

export interface GlobalOutputPath {
  readonly client: string;
  readonly path: string;
}


export class GlobalContextBuilder {
  constructor(
    private readonly globalConfigPath: string = DEFAULT_GLOBAL_CONFIG_PATH
  ) {}

  async buildGlobalContextFiles(): Promise<FileOperationResult<number>> {
    try {
      // Read and process component files
      const componentFiles = await this.loadComponentFiles();
      if (componentFiles.length === 0) {
        return {
          success: false,
          error: new Error('No component files found to build global context')
        };
      }

      // Build consolidated content
      const content = this.buildConsolidatedContent(componentFiles);

      // Write to all global output paths
      let filesWritten = 0;
      const builtFiles: string[] = [];
      
      const globalPaths = getGlobalConfigPaths();
      const outputPaths: GlobalOutputPath[] = [
        { client: 'claude', path: globalPaths.destinations.claude },
        { client: 'windsurf', path: globalPaths.destinations.windsurf }
      ];
      
      for (const outputPath of outputPaths) {
        const success = await this.writeGlobalContextFile(outputPath.path, content);
        if (success) {
          filesWritten++;
          builtFiles.push(outputPath.path);
          console.error(`✓ Built global context: ${outputPath.client}`);
        } else {
          console.error(`✗ Failed to build global context: ${outputPath.client}`);
        }
      }

      // Run markdown lint on all built files
      if (builtFiles.length > 0) {
        await this.runMarkdownLint(builtFiles);
      }

      return {
        success: filesWritten > 0,
        data: filesWritten
      };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error : new Error('Unknown build error')
      };
    }
  }

  private async loadComponentFiles(): Promise<ProcessedFile[]> {
    try {
      const globalPaths = getGlobalConfigPaths();
      const expandedPath = globalPaths.source;
      const files = await fs.readdir(expandedPath);
      const filePaths = files.map(file => path.join(expandedPath, file));

      const processedFiles: ProcessedFile[] = [];

      for (const filePath of filePaths) {
        try {
          const stat = await fs.stat(filePath);
          if (!stat.isFile()) continue;

          const filename = path.basename(filePath);
          const extension = path.extname(filePath);
          
          // Find matching file type
          const fileType = FILE_TYPES.find(type => type.extension === extension);
          if (!fileType) continue;

          const content = await fs.readFile(filePath, 'utf-8');
          
          processedFiles.push({
            path: filePath,
            filename,
            extension,
            content,
            priority: fileType.priority
          });
        } catch (error) {
          console.error(`✗ Error reading component file: ${filePath}`);
        }
      }

      // Sort by priority, then alphabetically
      return processedFiles.sort((a, b) => {
        if (a.priority !== b.priority) {
          return a.priority - b.priority;
        }
        return a.filename.localeCompare(b.filename);
      });
    } catch (error) {
      const globalPaths = getGlobalConfigPaths();
      console.error(`✗ Error loading component files from: ${globalPaths.source}`);
      return [];
    }
  }

  private buildConsolidatedContent(componentFiles: ProcessedFile[]): string {
    const sections: string[] = [];
    
    sections.push('# Global AI Configuration');
    sections.push('');
    sections.push('<!-- This file is automatically generated from component files in ~/.config/ai/global/ -->');
    sections.push('<!-- Do not edit directly - edit the component files instead -->');
    sections.push('');

    for (const file of componentFiles) {
      sections.push(`<!-- File: ${file.filename} -->`);
      
      if (file.extension === '.json') {
        // Format JSON as code block
        const title = this.getFileTitle(file.filename);
        sections.push(`## ${title}`);
        sections.push('');
        sections.push('```json');
        sections.push(file.content.trim());
        sections.push('```');
      } else if (file.extension === '.toml') {
        // Format TOML as code block
        const title = this.getFileTitle(file.filename);
        sections.push(`## ${title}`);
        sections.push('');
        sections.push('```toml');
        sections.push(file.content.trim());
        sections.push('```');
      } else if (file.extension === '.md') {
        // Include markdown directly
        sections.push(file.content.trim());
      }
      
      sections.push('');
    }

    return sections.join('\n');
  }

  private getFileTitle(filename: string): string {
    // Convert filename to title case
    // e.g., "code-style.json" -> "Code Style"
    const baseName = path.basename(filename, path.extname(filename));
    return baseName
      .split('-')
      .map(word => word.charAt(0).toUpperCase() + word.slice(1))
      .join(' ');
  }

  private async writeGlobalContextFile(outputPath: string, content: string): Promise<boolean> {
    try {
      // Ensure directory exists
      const dir = path.dirname(outputPath);
      await fs.ensureDir(dir);
      
      // Write content
      await fs.writeFile(outputPath, content, 'utf-8');
      return true;
    } catch (error) {
      console.error(`✗ Error writing global context file: ${outputPath}`);
      console.error(`  ${error instanceof Error ? error.message : 'Unknown error'}`);
      return false;
    }
  }

  private async runMarkdownLint(filePaths: string[]): Promise<void> {
    try {
      process.stderr.write('\n'); // Blank line before lint
      console.error('→ Running markdown lint...');
      
      // Use markdownlint-cli2 for better performance and configuration
      const command = `npx markdownlint-cli2 "${filePaths.join('" "')}"`;
      
      execSync(command, { 
        stdio: ['pipe', 'pipe', 'pipe'],
        encoding: 'utf8'
      });
      
      console.error('✓ Markdown lint passed');
      process.stderr.write('\n'); // Blank line after lint
    } catch (error) {
      // Markdown lint failures shouldn't stop the build process
      console.error('⚠ Markdown lint issues found:');
      if (error instanceof Error && 'stdout' in error) {
        const output = (error as any).stdout || (error as any).stderr || error.message;
        // Show lint output but don't fail the build
        console.error(output.trim());
      }
      process.stderr.write('\n'); // Blank line after lint errors
    }
  }
}